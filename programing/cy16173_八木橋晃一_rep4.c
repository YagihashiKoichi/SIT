/*
ｃｙ１６１７３　八木橋晃一　2017/05/11		演習５

関数の説明
入力された文字列の中にある括弧の対応が正しいかどうか判断する関数。
対応が正しい場合は"OK"と出力される。
対応が正しくない場合は0から数えて何番目と何番目が対応していないかが出力される。
-1は対応する括弧が存在しないことを示す。
スペースをいれるとそこで文字列がそこで終わっていると判断されっるので注意が必要である。
開き括弧が18回以上続くとオーバーフローがおこる。


テスト
正しい入力1
str[20]={"((a{bg})c(dh{e})f)f"}(19文字:max)
結果:OK

正しい入力2
str[20]={"()"}(2文字)
結果:OK

正しい入力3(括弧が１つも無い)
str[20]={"111"}
結果:OK(popとpushの呼び出し回数がともに0回のため)


誤った入力1(１つ前の括弧によるエラー,'{'と')')
str[20]={"((ab)c(de{f)g}h)"}
結果:ERROR at 9:11

誤った入力2(離れた位置にある'('と'}'によるエラー)
str[20]={"()({}(as)86}12"}
結果:ERROR at 2:11

誤った入力3(オーバーフローを予想)
str[20]={"{{{{{{{{{{{{{(((((("}(stakcに限界を超える量を入れる)
結果:オーバーフローがおこる入力です。

誤った入力4(アンダーフローを予想)
str[20]={"(a(bc)d))"}(at -1となるがアンダーフロー)
結果:アンダーフローがおこる入力です。
		ERROR at -1:8

誤った入力5(間違った括弧の対応を2つ)
str[20]={"{{){)"}(前の方のERRORしか表示されない)
結果:ERROR at 1:2

誤った入力6(スペースを入れる)
str[20]={"{}{ }()"}
結果:ERROR at 0:-1(スペースを入れるとヌル文字扱いで、そこから先は認識されない)
*/

#include<stdio.h>

int	push(char	c);
char	pop();												//プロトタイプ宣言

int	sp=0,i=0;										//spはスタックのカウンター変数、iは文字列のカウンター変数
char	stack[19]={""};							//グローバル変数

int	main(void)
{
	char	str[20]={""};
	char	l,handan;																									
	int	hantei,i=0,k=0,t=0,n=0,i2,pushhatui,popnoi,kakuninti=0;		

/*
lはpopされた文字、handanは￥￥のコメントのところで使用、文字をさかのぼる時もじを保存
それぞれi:文字(箱)、k:push、t:popのカウンター変数,
hanteiはpushの返り値を保存
nは使い捨て関数のカウンター変数,		i2はiの値を一時的に保管,
pushhatuiは初めてpushされた際のiの値を保管
popnoiはpushの際のiの値を一時的に保管
*/
	
	printf("19文字以内で入力してください。\n");
	scanf("%s",str);

	while(1)			
	{	

		if(str[i]=='\0')	break;

		if((str[i]=='{')||(str[i]=='('))												//(または{をpush
		{
			hantei=push(str[i]);
			if(n==0)
			{
				pushhatui=i;																																				//初めてpushされた際のiの値を保管
				n++;
			}
			sp++;
			if(hantei==0)
			{
				printf("オーバーフローがおこる入力です。");
				return	0;
			}
			k++;	
		}

		if((str[i]=='}')||(str[i]==')'))
		{
			sp=sp-1;							/*sのままだと次の括弧を受け取るための空欄、
															取り出した括弧は不要なため-1したあとは元に戻さずpushの際に上書きさせる*/
		

			l=pop();						//}または)だったらpop()する
			popnoi=i;
			if(l=='\0')
			{
				printf("アンダーフローがおこる入力です。");			//前に対応する括弧がない、アンダーフロー
				printf("ERROR at -1:%d",popnoi);
				return	0;
			}
			t++;

			if(((str[i]=='}')&&(l!='{'))||((str[i]==')')&&(l!='(')))		
			{
				i2=i;					//iの値を保管
				while(1)
				{
					handan=str[i2];																																			//\\							
					if((handan=='}')||(handan==')'))							//'}'または')'ならkakunintiの値に１を足す
						kakuninti++;
					if((handan=='{')||(handan=='('))						//'}'または')'ならkakunintiの値に１を引く
						kakuninti--;
					if(kakuninti==0)																																//kakunintiの値が0になったら非対応の括弧と認識
						break;
					i2--;
					
				}
				printf("ERROR at %d:%d",i2,i);							//括弧が対応していない
				return	0;
			}

		}
		i++;	
	}

	if(sp-1==0)		//後ろに対応する括弧がない
	{
		printf("ERROR at %d:-1",pushhatui);
		return	0;
	}


	if(t==0&&k==0)			//popもpushも呼び出されない＝括弧がない
	{
		printf("OK");
		return	0;
	}
	printf("OK");
	return	0;
}

/*
pushのテストはない（メインでオーバーフローの判断をしているため）
引数（文字）をプッシュし保存する関数

引数:'{'または'('の開き括弧（ｃのこと）
返り値１:オーバーフローしなかったら1
返り値2:オーバーフローしたら0
*/
int	push(char	c)
{
	if(18<=sp)	
		return	0;
	stack[sp]=c;
	return	1;
}




/*
popのテストはない（メインでアンダーフローの判断をしているため）
プッシュで入れられた文字をポップする(だす)関数
引数：なし
返り値１:アンダーフローしなかったら最後にプッシュされた文字（開き括弧）
返り値2:アンダーフローしたら0
*/
char	pop()
{
	char	L;
	if(sp<0)	
		return	0;
	L=stack[sp];
	return	L;
}
